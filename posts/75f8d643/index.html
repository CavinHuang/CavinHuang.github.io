<!DOCTYPE html><html lang="zh"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="baidu-site-verification" content="rqskM4bdtP"><meta name="viewport" content="device-width, initial-scale=1, maximum-scale=1,user-scalable=no"><title>centos7结合supervisor和think-queue实现队列-CavinHuangのBlog-http://blog.zukmb.cn</title><meta name="keywords" content="前端学习,php学习,个人博客,HTML,CSS,JS"><meta name="description" content="cavinHuang个人博客，这里记录学习和生活的点滴！"><meta name="google-site-verification" content="zOYxWUgmeogC0qY76WLP0eWl8r9E8jk_qU927Ij7tbs"><script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5a4c3745fa28006f"></script><link rel="stylesheet" href="/css/yoyo.css"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.3"><script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script><script src="https://cdn.bootcss.com/velocity/1.5.0/velocity.min.js"></script><meta name="generator" content="Hexo 5.3.0"><link rel="stylesheet" href="/css/prism-base16-ateliersulphurpool.light.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body></body></html><div class="app"><div class="left-container"><div class="left-layout-container pc"><div class="user-info"><a href="/"><img src="https://avatars1.githubusercontent.com/u/24950299?s=460&amp;v=4"></a><div class="login-name">CavinHuang</div><div class="slog">来不及总结自己,愿天大地大,我独一无二!</div></div><ul class="other-site"><li><img src="http://www.17sucai.com/preview/177065/2017-09-28/Mon9/static/img/github.png"></li><li><img src="http://www.17sucai.com/preview/177065/2017-09-28/Mon9/static/img/weibo.png"></li></ul><ul class="left-menu"><li><a href="/archives">文章</a></li><li><a href="/categories">分类</a></li><li><a href="/tags">标签</a></li><li><a href="/about">关于</a></li></ul><div class="qq-group"><span>读万卷书</span><span>行万里路</span></div><div class="copyright">@ 2017 - 2017 CavinHuang</div></div></div><div id="app-aside"><aside class="aside"><div class="aside-user"><div class="avatar"><img src="https://avatars1.githubusercontent.com/u/24950299?s=460&amp;v=4" alt="CavinHuang"></div><div class="profile"><h3 class="name">CavinHuang</h3><p class="email">来不及总结自己,愿天大地大,我独一无二!</p></div></div><div class="aside-nav"><nav class="nav-list"><a class="item" href="/archives"><span>文章</span></a><a class="item" href="/categories"><span>分类</span></a><a class="item" href="/tags"><span>标签</span></a><a class="item" href="/about"><span>关于</span></a></nav></div></aside></div><div class="blog-container main-container" id="content-outer"><nav class="navbar"><div class="navbar-container"><div class="navbar-header"><a class="navbar-menu" id="navMenu" href="javascript:;" data-isOpen="false"><i class="iconfont icon-menu"></i></a><a class="navbar-logo" href="/"><img src="/assets/img/logo.png"></a><a class="navbar-search" href=""></a></div></div></nav><div class="blog-list-container" id="content-inner"><article class="article-container" id="post"><div class="article-header"><h1 class="article-title">centos7结合supervisor和think-queue实现队列</h1><div class="article-subtitle"><div class="publish-time fl">发布时间:<span>2017/9/15 9:2:20</span></div><div class="categories">分类:<a href="/categories/server/"><span>服务器操作</span></a></div></div></div><div class="article-word-count"><ul><div class="word-count-item">全文约<span class="post-count">9.3k</span>字</div><div class="word-count-item">预计需要<span class="post-count">36</span>分钟</div></ul></div><div class="article-content"><blockquote><p>Linux的后台进程运行有好几种方法，例如nohup，screen等，但是，如果是一个服务程序，要可靠地在后台运行，我们就需要把它做成daemon，最好还能监控进程状态，在意外结束时能自动重启。 supervisor就是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。</p></blockquote><a id="more"></a><h1 id="安装supervisor"><a href="#安装supervisor" class="headerlink" title="安装supervisor"></a>安装supervisor</h1><blockquote><p>【注】 linux环境必须安装 python</p></blockquote><h2 id="1-获取supervisor包：【https-pypi-python-org-pypi-supervisor】"><a href="#1-获取supervisor包：【https-pypi-python-org-pypi-supervisor】" class="headerlink" title="1.获取supervisor包：【https://pypi.python.org/pypi/supervisor】"></a>1.获取supervisor包：【<a target="_blank" rel="noopener" href="https://pypi.python.org/pypi/supervisor%E3%80%91">https://pypi.python.org/pypi/supervisor】</a></h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># wget https://pypi.python.org/packages/80/37/964c0d53cbd328796b1aeb7abea4c0f7b0e8c7197ea9b0b9967b7d004def/supervisor-3.3.1.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-解压supervisor-3-3-1-tar-gz-并安装"><a href="#2-解压supervisor-3-3-1-tar-gz-并安装" class="headerlink" title="2.解压supervisor-3.3.1.tar.gz 并安装"></a>2.解压supervisor-3.3.1.tar.gz 并安装</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># tar zxvf supervisor-3.3.1.tar.gz &amp;&amp; cd supervisor-3.3.1</span>

<span class="token comment" spellcheck="true"># python setup.py install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>【可能报错】：ImportError: No module named setuptools</p><p>【解决办法】：没有setuptools的模块，说明python缺少这个模块，那我们只要安装这个模块即可解决此问题</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># wget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gz</span>

<span class="token comment" spellcheck="true"># tar zxvf setuptools-0.6c11.tar.gz &amp;&amp; cd setuptools-0.6c11</span>

<span class="token comment" spellcheck="true"># python setup.py build</span>

<span class="token comment" spellcheck="true"># python setup.py install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-创建supervisor的配置文件："><a href="#3-创建supervisor的配置文件：" class="headerlink" title="3.创建supervisor的配置文件："></a>3.创建supervisor的配置文件：</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># echo_supervisord_conf > /etc/supervisord.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-开启supervisord服务"><a href="#4-开启supervisord服务" class="headerlink" title="4.开启supervisord服务"></a>4.开启supervisord服务</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisord -c /etc/supervisord.conf</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-更新新的配置到supervisord"><a href="#5-更新新的配置到supervisord" class="headerlink" title="5.更新新的配置到supervisord"></a>5.更新新的配置到supervisord</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl update</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-重新启动配置中的所有程序"><a href="#6-重新启动配置中的所有程序" class="headerlink" title="6.重新启动配置中的所有程序"></a>6.重新启动配置中的所有程序</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl reload</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-启动某个进程-program-name-你配置中写的程序名称"><a href="#7-启动某个进程-program-name-你配置中写的程序名称" class="headerlink" title="7.启动某个进程(program_name=你配置中写的程序名称)"></a>7.启动某个进程(program_name=你配置中写的程序名称)</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl start program_name</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="8-查看正在守候的进程"><a href="#8-查看正在守候的进程" class="headerlink" title="8.查看正在守候的进程"></a>8.查看正在守候的进程</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="9-重启某一进程-program-name-你配置中写的程序名称"><a href="#9-重启某一进程-program-name-你配置中写的程序名称" class="headerlink" title="9.重启某一进程 (program_name=你配置中写的程序名称)"></a>9.重启某一进程 (program_name=你配置中写的程序名称)</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl restart program_name</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="10-停止全部进程"><a href="#10-停止全部进程" class="headerlink" title="10.停止全部进程"></a>10.停止全部进程</h2><pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># supervisorctl stop all</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="11-查看supervisord进程"><a href="#11-查看supervisord进程" class="headerlink" title="11.查看supervisord进程"></a>11.查看supervisord进程</h2><p><img src="/posts/75f8d643/blogimg/supervisorctl_sh.png%22%E8%BF%9B%E7%A8%8B%22" alt="进程"></p><hr><blockquote><p>传统的程序执行流程一般是 即时|同步|串行的，在某些场景下，会存在并发低，吞吐量低，响应时间长等问题。在大型系统中，一般会引入消息队列的组件，将流程中部分任务抽离出来放入消息队列，并由专门的消费者作针对性的处理，从而降低系统耦合度，提高系统性能和可用性。<br>一般来说，可以抽离的任务具有以下的特点：</p></blockquote><ul><li>** 允许延后|异步|并行处理 ** （相对于传统的 <strong>即时|同步|串行</strong> 的执行方式）<ul><li><strong>允许延后</strong>：<br>抢购活动时，先快速缓冲有限的参与人数到消息队列，后续再排队处理实际的抢购业务；</li><li><strong>允许异步</strong>：<br>业务处理过程中的邮件，短信等通知</li><li><strong>允许并行</strong>：<br>用户支付成功之后，邮件通知，微信通知，短信通知可以由多个不同的消费者并行执行，通知到达的时间不要求先后顺序。</li></ul></li><li>** 允许失败和重试 **<ul><li>强一致性的业务放入核心流程处理</li><li>无一致性要求或最终一致即可的业务放入队列处理</li></ul></li></ul><p>** <a target="_blank" rel="noopener" href="https://github.com/top-think/think-queue/releases">thinkphp-queue</a> ** 是thinkphp 官方提供的一个消息队列服务，它支持消息队列的一些基本特性：</p><ul><li>消息的<strong>发布</strong>，<strong>获取</strong>，<strong>执行</strong>，<strong>删除</strong>，<strong>重发</strong>，<strong>失败处理</strong>，<strong>延迟执行</strong>，<strong>超时控制</strong>等</li><li>队列的<strong>多队列</strong>， <strong>内存限制</strong> ，<strong>启动</strong>，<strong>停止</strong>，<strong>守护</strong>等</li><li>消息队列可<strong>降级为同步执行</strong></li></ul><p>thinkphp-queue 内置了 <strong>Redis</strong>，<strong>Database</strong>，<strong>Topthink</strong> ，<strong>Sync</strong>这四种驱动。本文主要介绍 thinkphp-queue 结合其内置的 redis 驱动的使用方式和基本原理。</p><p>注1：如无特殊说明，下文中的 ‘消息’ 和 ‘任务’两个词指代的是同一个概念，即队列中的一个成员。该成员对消息队列而言是其内部保存的消息； 对业务应用而言是一个待执行的任务。请根据语境区分。</p><p>注2：本文编写时(2017-02-15)使用的 thinkphp-queue 的版本号是 v1.1.2 。该版本中部分功能并未全部完成，如 subscribe 模式，以及存在几个bug(稍后会提及)。如有变更，请以官方最新版为准。</p><h3 id="一-代码示例"><a href="#一-代码示例" class="headerlink" title="一 代码示例"></a>一 代码示例</h3><p>先通过一段代码，了解一下 thinkphp-queue 的基本使用流程。</p><blockquote><p>目标：</p></blockquote><blockquote><p>在业务控制器中推送一个新消息到一个名为 ‘helloJobQueue’ 的队列中，该消息中包含我们自定义的业务数据，然后，编写一个名为 Hello 的消费者类，并通过命令行去调用该消费者类获取这个消息，拿到定义的数据。</p></blockquote><h1 id="安装-thinkphp-queue"><a href="#安装-thinkphp-queue" class="headerlink" title="安装 thinkphp-queue"></a>安装 thinkphp-queue</h1><pre class="line-numbers language-bash"><code class="language-bash">composer <span class="token function">install</span> thinkphp-queue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="搭建消息队列的存储环境"><a href="#搭建消息队列的存储环境" class="headerlink" title="搭建消息队列的存储环境"></a>搭建消息队列的存储环境</h2><ul><li>使用 Redis [<strong>推荐</strong>]<pre class="line-numbers language-json"><code class="language-json">安装并启动 Redis 服务<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用数据库 [不推荐]<pre class="line-numbers language-mysql"><code class="language-mysql">CREATE TABLE `prefix_jobs` (
`id` int(11) NOT NULL AUTO_INCREMENT,
`queue` varchar(255) NOT NULL,
`payload` longtext NOT NULL,
`attempts` tinyint(3) unsigned NOT NULL,
`reserved` tinyint(3) unsigned NOT NULL,
`reserved_at` int(10) unsigned DEFAULT NULL,
`available_at` int(10) unsigned NOT NULL,
`created_at` int(10) unsigned NOT NULL,
PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="配置消息队列的驱动"><a href="#配置消息队列的驱动" class="headerlink" title="配置消息队列的驱动"></a>配置消息队列的驱动</h2><p>根据选择的存储方式，在 <code>\application\extra\queue.php</code> 这个配置文件中，添加消息队列对应的驱动配置</p><pre class="line-numbers language-php"><code class="language-php">   <span class="token keyword">return</span> <span class="token punctuation">[</span>
       <span class="token string">'connector'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'Redis'</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// Redis 驱动</span>
       <span class="token string">'expire'</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token number">60</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 任务的过期时间，默认为60秒; 若要禁用，则设置为 null</span>
       <span class="token string">'default'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'default'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// 默认的队列名称</span>
       <span class="token string">'host'</span>       <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span>        <span class="token comment" spellcheck="true">// redis 主机ip</span>
       <span class="token string">'port'</span>       <span class="token operator">=</span><span class="token operator">></span> <span class="token number">6379</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// redis 端口</span>
       <span class="token string">'password'</span>   <span class="token operator">=</span><span class="token operator">></span> <span class="token string">''</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// redis 密码</span>
       <span class="token string">'select'</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// 使用哪一个 db，默认为 db0</span>
       <span class="token string">'timeout'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">,</span>                <span class="token comment" spellcheck="true">// redis连接的超时时间</span>
       <span class="token string">'persistent'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">false</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// 是否是长连接</span>

   <span class="token comment" spellcheck="true">//    'connector' => 'Database',   // 数据库驱动</span>
   <span class="token comment" spellcheck="true">//    'expire'    => 60,           // 任务的过期时间，默认为60秒; 若要禁用，则设置为 null</span>
   <span class="token comment" spellcheck="true">//    'default'   => 'default',    // 默认的队列名称</span>
   <span class="token comment" spellcheck="true">//    'table'     => 'jobs',       // 存储消息的表名，不带前缀</span>
   <span class="token comment" spellcheck="true">//    'dsn'       => [],</span>

   <span class="token comment" spellcheck="true">//    'connector'   => 'Topthink',    // ThinkPHP内部的队列通知服务平台 ，本文不作介绍</span>
   <span class="token comment" spellcheck="true">//    'token'       => '',</span>
   <span class="token comment" spellcheck="true">//    'project_id'  => '',</span>
   <span class="token comment" spellcheck="true">//    'protocol'    => 'https',</span>
   <span class="token comment" spellcheck="true">//    'host'        => 'qns.topthink.com',</span>
   <span class="token comment" spellcheck="true">//    'port'        => 443,</span>
   <span class="token comment" spellcheck="true">//    'api_version' => 1,</span>
   <span class="token comment" spellcheck="true">//    'max_retries' => 3,</span>
   <span class="token comment" spellcheck="true">//    'default'     => 'default',</span>

   <span class="token comment" spellcheck="true">//    'connector'   => 'Sync',        // Sync 驱动，该驱动的实际作用是取消消息队列，还原为同步执行</span>
   <span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>1.3.1 配置文件中的 expire 参数说明</strong></p><p>expire 参数指的是任务的过期时间。 过期的任务，其准确的定义是</p><ol><li>任务的状态为执行中</li><li>任务的开始执行的时刻 + expire &gt; 当前时刻</li></ol><p>expire 不为<code>null</code> 时 ，thinkphp-queue 会在每次获取下一个任务之前检查并重发过期(执行超时)的任务。</p><p>expire 为<code>null</code> 时，thinkphp-queue 不会检查过期的任务，性能相对较高一点。但是需要注意：</p><ul><li>这些执行超时的任务会一直留在消息队列中，需要开发者另行处理(删除或者重发)！</li><li>[ **<a target="_blank" rel="noopener" href="https://github.com/top-think/think-queue/issues/12">Bug</a>** ]在redis 驱动下，expire 设置为 null 时，无法实现任务的延迟执行! (Database 驱动下无影响)</li></ul><p><strong>对expire 参数理解或者使用不当时，很容易产生一些bug</strong>，后面会举例提到。</p><h3 id="消息的创建与推送"><a href="#消息的创建与推送" class="headerlink" title="消息的创建与推送"></a>消息的创建与推送</h3><p>我们在业务控制器中创建一个新的消息，并推送到 <code>helloJobQueue</code> 队列</p><p>新增 <code>\application\index\controller\JobTest.php</code> 控制器，在该控制器中添加 <code>actionWithHelloJob</code> 方法</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token comment" spellcheck="true">/**
* 文件路径： \application\index\controller\JobTest.php
* 该控制器的业务代码中借助了thinkphp-queue 库，将一个消息推送到消息队列
*/</span>
<span class="token keyword">namespace</span> <span class="token package">application<span class="token punctuation">\</span>index<span class="token punctuation">\</span>controller</span><span class="token punctuation">;</span>
  <span class="token keyword">use</span> <span class="token package">think<span class="token punctuation">\</span>Exception</span><span class="token punctuation">;</span>

  <span class="token keyword">use</span> <span class="token package">think<span class="token punctuation">\</span>Queue</span><span class="token punctuation">;</span>

  <span class="token keyword">class</span> <span class="token class-name">JobTest</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
  <span class="token comment" spellcheck="true">/**
   * 一个使用了队列的 action
   */</span>
  <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">actionWithHelloJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

      <span class="token comment" spellcheck="true">// 1.当前任务将由哪个类来负责处理。</span>
      <span class="token comment" spellcheck="true">//   当轮到该任务时，系统将生成一个该类的实例，并调用其 fire 方法</span>
      <span class="token variable">$jobHandlerClassName</span>  <span class="token operator">=</span> <span class="token string">'application\index\job\Hello'</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 2.当前任务归属的队列名称，如果为新队列，会自动创建</span>
      <span class="token variable">$jobQueueName</span>        <span class="token operator">=</span> <span class="token string">"helloJobQueue"</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 3.当前任务所需的业务数据 . 不能为 resource 类型，其他类型最终将转化为json形式的字符串</span>
      <span class="token comment" spellcheck="true">//   ( jobData 为对象时，需要在先在此处手动序列化，否则只存储其public属性的键值对)</span>
      <span class="token variable">$jobData</span>             <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">'ts'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'bizId'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">uniqid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">,</span> <span class="token string">'a'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">1</span> <span class="token punctuation">]</span> <span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 4.将该任务推送到消息队列，等待对应的消费者去执行</span>
      <span class="token variable">$isPushed</span> <span class="token operator">=</span> Queue<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">push</span><span class="token punctuation">(</span> <span class="token variable">$jobHandlerClassName</span> <span class="token punctuation">,</span> <span class="token variable">$jobData</span> <span class="token punctuation">,</span> <span class="token variable">$jobQueueName</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// database 驱动时，返回值为 1|false  ;   redis 驱动时，返回值为 随机字符串|false</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$isPushed</span> <span class="token operator">!==</span> <span class="token boolean">false</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;  </span>
          <span class="token keyword">echo</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string">'Y-m-d H:i:s'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span> <span class="token string">" a new Hello Job is Pushed to the MQ"</span><span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>
          <span class="token keyword">echo</span> <span class="token string">'Oops, something went wrong.'</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
 <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意:</strong> 在这个例子当中，我们是手动指定的 <code>$jobHandlerClassName</code> ，更合理的做法是先定义好消息名称与消费者类名的映射关系，然后由某个可以获取该映射关系的类来推送这个消息。这样，生产者只需要知道消息的名称，而无需指定哪个消费者类来处理。</p><blockquote><p>除了 <code>Queue::push( $jobHandlerClassName , $jobData , $jobQueueName );</code>这种方式之外，还可以直接传入 <code>Queue::push( $jobHandlerObject ,null , $jobQueueName );</code> 这时，需要在 $jobHandlerObject 中定义一个 <code>handle()</code> 方法，消息队列在执行到该任务时会自动反序列化该对象，并调用其 <code>handle()</code>方法。 该方式的缺点是无法传入自定义数据。</p></blockquote><h3 id="消息的消费与删除"><a href="#消息的消费与删除" class="headerlink" title="消息的消费与删除"></a>消息的消费与删除</h3><p>编写 Hello 消费者类，用于处理 <code>helloJobQueue</code> 队列中的任务</p><p>新增 <code>\application\index\job\Hello.php</code> 消费者类，并编写其 <code>fire()</code> 方法</p><pre class="line-numbers language-php"><code class="language-php"> <span class="token delimiter">&lt;?php</span>
  <span class="token comment" spellcheck="true">/**
   * 文件路径： \application\index\job\Hello.php
   * 这是一个消费者类，用于处理 helloJobQueue 队列中的任务
   */</span>
  <span class="token keyword">namespace</span> <span class="token package">application<span class="token punctuation">\</span>index<span class="token punctuation">\</span>job</span><span class="token punctuation">;</span>

  <span class="token keyword">use</span> <span class="token package">think<span class="token punctuation">\</span>queue<span class="token punctuation">\</span>Job</span><span class="token punctuation">;</span>

  <span class="token keyword">class</span> <span class="token class-name">Hello</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

      <span class="token comment" spellcheck="true">/**
       * fire方法是消息队列默认调用的方法
       * @param Job            $job      当前的任务对象
       * @param array|mixed    $data     发布任务时自定义的数据
       */</span>
      <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">fire</span><span class="token punctuation">(</span>Job <span class="token variable">$job</span><span class="token punctuation">,</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

          <span class="token variable">$isJobDone</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">doHelloJob</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$isJobDone</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
              <span class="token comment" spellcheck="true">//如果任务执行成功， 记得删除任务</span>
              <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
              <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;info>Hello Job has been done and deleted"</span><span class="token punctuation">.</span><span class="token string">"&lt;/info>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>
              <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">attempts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
                  <span class="token comment" spellcheck="true">//通过这个方法可以检查这个任务已经重试了几次了</span>
                  <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;warn>Hello Job has been retried more than 3 times!"</span><span class="token punctuation">.</span><span class="token string">"&lt;/warn>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token comment" spellcheck="true">// 也可以重新发布这个任务</span>
                  <span class="token comment" spellcheck="true">//print("</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>info</span><span class="token punctuation">></span></span></span>Hello Job will be availabe again after 2s<span class="token punctuation">.</span><span class="token string">"."</span><span class="token markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>info</span><span class="token punctuation">></span></span></span>\<span class="token package">n</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>
                  <span class="token comment" spellcheck="true">//$job->release(2); //$delay为延迟时间，表示该任务延迟2秒后再执行</span>
              <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
          <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

      <span class="token comment" spellcheck="true">/**
       * 根据消息中的数据进行实际的业务处理
       * @param array|mixed    $data     发布任务时自定义的数据
       * @return boolean                 任务执行的结果
       */</span>
      <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">doHelloJob</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
          <span class="token comment" spellcheck="true">// 根据消息中的数据进行实际的业务处理...</span>

          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;info>Hello Job Started. job Data is: "</span><span class="token punctuation">.</span><span class="token function">var_export</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"&lt;/info> \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;info>Hello Job is Fired at "</span> <span class="token punctuation">.</span> <span class="token function">date</span><span class="token punctuation">(</span><span class="token string">'Y-m-d H:i:s'</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token string">"&lt;/info> \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"&lt;info>Hello Job is Done!"</span><span class="token punctuation">.</span><span class="token string">"&lt;/info> \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>至此，所有的代码都已准备完毕，在运行消息队列之前，我们先看一下现在的目录结构：</p><p><img src="/posts/75f8d643/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B.png" alt="目录结构-代码示例"></p><h3 id="发布任务"><a href="#发布任务" class="headerlink" title="发布任务"></a>发布任务</h3><p>在浏览器中访问 <a target="_blank" rel="noopener" href="http://your.project.domain/index/job_test/actionWithHelloJob">http://your.project.domain/index/job_test/actionWithHelloJob</a> ,可以看到消息推送成功。</p><p><img src="/posts/75f8d643/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%90%E7%A4%BA%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E7%BB%93%E6%9E%9C.png" alt="浏览器提示消息推送结果"></p><h3 id="处理任务"><a href="#处理任务" class="headerlink" title="处理任务"></a>处理任务</h3><p>切换当前终端窗口的目录到项目根目录下，执行</p><pre class="line-numbers language-bash"><code class="language-bash">php think queue:work --queue helloJobQueue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到执行的结果类似如下:</p><p><img src="/posts/75f8d643/%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="命令行执行结果"></p><p>至此，我们成功地经历了一个消息的 创建 -&gt; 推送 -&gt; 消费 -&gt; 删除 的基本流程</p><p>下文，将介绍 thinkphp-queue 的详细使用方法。如配置介绍，基本原理，各种特殊情况的处理等</p><h2 id="二-详细介绍"><a href="#二-详细介绍" class="headerlink" title="二 详细介绍"></a>二 详细介绍</h2><h3 id="2-1-命令模式"><a href="#2-1-命令模式" class="headerlink" title="2.1 命令模式"></a>2.1 命令模式</h3><ul><li><p><strong>queue:subscribe 命令</strong> [截至2017-02-15，作者暂未实现该模式，略过]</p></li><li><p><strong>queue:work 命令</strong></p><p>work 命令： 该命令将启动一个 work 进程来处理消息队列。</p><pre class="line-numbers language-bash"><code class="language-bash">php think queue:work --queue helloJobQueue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>queue:listen 命令</strong></p><p>listen 命令： 该命令将会创建一个 listen 父进程 ，然后由父进程通过 <code>proc_open(‘php think queue:work’)</code> 的方式来创建一个work 子 进程来处理消息队列，且限制该work进程的执行时间。</p><pre class="line-numbers language-bash"><code class="language-bash">php think queue:listen --queue helloJobQueue<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h3 id="2-2-命令行参数"><a href="#2-2-命令行参数" class="headerlink" title="2.2 命令行参数"></a>2.2 命令行参数</h3><ul><li><p>Work 模式</p><pre class="line-numbers language-bash"><code class="language-bash">php think queue:work \
--daemon            //是否循环执行，如果不加该参数，则该命令处理完下一个消息就退出
--queue  helloJobQueue  //要处理的队列的名称
--delay  0 \        //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0
--force  \          //系统处于维护状态时是否仍然处理任务，并未找到相关说明
--memory 128 \      //该进程允许使用的内存上限，以 M 为单位
--sleep  3 \        //如果队列中无任务，则sleep多少秒后重新检查<span class="token punctuation">(</span>work+daemon模式<span class="token punctuation">)</span>或者退出<span class="token punctuation">(</span>listen或非daemon模式<span class="token punctuation">)</span>
--tries  2          //如果任务已经超过尝试次数上限，则触发‘任务尝试次数超限’事件，默认为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Listen 模式</p><pre class="line-numbers language-bash"><code class="language-bash">php think queue:listen \
--queue  helloJobQueue \   //监听的队列的名称
--delay  0 \         //如果本次任务执行抛出异常且任务未被删除时，设置其下次执行前延迟多少秒,默认为0
--memory 128 \       //该进程允许使用的内存上限，以 M 为单位
--sleep  3 \         //如果队列中无任务，则多长时间后重新检查，daemon模式下有效
--tries  0 \         //如果任务已经超过重发次数上限，则进入失败处理逻辑，默认为0
--timeout 60         //创建的work子进程的允许执行的最长时间，以秒为单位<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到 listen 模式下，不包含 <code>--deamon</code> 参数，原因下面会说明</p></li></ul><h3 id="2-3-work-模式和-listen-模式的区别"><a href="#2-3-work-模式和-listen-模式的区别" class="headerlink" title="2.3 work 模式和 listen 模式的区别"></a>2.3 work 模式和 listen 模式的区别</h3><p>两者都可以用于处理消息队列中的任务区别在于:</p><ul><li><p>2.3.1 执行原理不同**</p><ul><li>work 命令是<strong>单进程</strong>的处理模式。<br>按照是否设置了 <code>--daemon</code> 参数，work命令又可分为单次执行和循环执行两种模式。<br>单次执行：不添加 <code>--daemon</code>参数，该模式下,work进程在处理完下一个消息后直接结束当前进程。当不存在新消息时，会sleep一段时间然后退出。<br>循环执行：添加了 <code>--daemon</code>参数，该模式下,work进程会循环地处理队列中的消息，直到内存超出参数配置才结束进程。当不存在新消息时，会在每次循环中sleep一段时间。</li><li>listen 命令是 <strong>父进程 + 子进程</strong> 的处理模式。<br>listen命令所在的父进程会创建一个<strong>单次执行模式的work子进程</strong>，并通过该work子进程来处理队列中的下一个消息，当这个work子进程退出之后，listen命令所在的父进程会监听到该子进程的退出信号，并重新创建一个新的<strong>单次执行的work子进程</strong></li></ul></li><li><p>2.3.2 退出时机不同**</p><ul><li>work 命令的退出时机在上面的执行原理部分已叙述，此处不再重复</li><li>listen 命令中，listen所在的父进程正常情况会一直运行，除非遇到下面两种情况：<br>创建的某个work子进程的执行时间超过了 listen命令行中的<code>--timeout</code> 参数配置，此时work子进程会被强制结束，listen所在的父进程也会抛出一个 <code>ProcessTimeoutException</code> 异常并退出。开发者可以选择捕获该异常，让父进程继续执行，也可以选择通过 supervisor 等监控软件重启一个新的listen命令。<br>listen 命令所在的父进程因某种原因存在内存泄露，则当父进程本身占用的内存超过了命令行中的 <code>--memory</code> 参数配置时，父子进程均会退出。正常情况下，listen进程本身占用的内存是稳定不变的。</li></ul></li><li><p>2.3.3 性能不同**</p><ul><li>work 命令是在脚本内部做循环，框架脚本在命令执行的初期就已加载完毕；</li><li>而listen模式则是处理完一个任务之后新开一个work进程，此时会重新加载框架脚本。<br>因此： <strong>work 模式的性能会比listen模式高</strong>。<br>注意：当代码有更新时，work 模式下需要手动去执行 <code>php think queue:restart</code> 命令重启队列来使改动生效；而listen 模式会自动生效,无需其他操作。</li></ul></li><li><p><strong>2.3.4 超时控制能力</strong></p><ul><li>work 模式本质上既不能控制进程自身的运行时间，也无法限制执行中的任务的执行时间。<br>举例来说，假如你在某次上线之后，在上文中的 <code>\application\index\job\Hello.php</code> 消费者的<code>fire</code>方法中添加了一段死循环 ：<pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123; </span><span class="token comment" spellcheck="true">//死循环</span>
       <span class="token variable">$consoleOutPut</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">writeln</span><span class="token punctuation">(</span><span class="token string">"&lt;info>I am looping forever inside a job.&lt;/info> \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
<span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> 那么这个循环将永远不能停止，直到任务所在的进程超过内存限制或者由管理员手动结束。这个过程不会有任何的告警。更严重的是，如果你配置了expire ，那么这个死循环的任务可能会污染到同样处理 <code>helloJobQueue</code> 队列的其他work进程，最后好几个work进程将被卡死在这段死循环中。详情后文会说明。<br><strong>work 模式下的超时控制能力，实际上应该理解为 多个work 进程配合下的过期任务重发能力。</strong></li><li>而 listen命令可以限制其创建的work子进程的超时时间。<br>listen 命令可通过 <code>--timeout</code> 参数限制work子进程允许运行的最长时间，超过该时间限制仍未结束的子进程会被强制结束；</li><li>这里有必要补充一下 expire 和 timeout 之间的区别：<br>expire 在配置文件中设置，timeout 在 listen命令 的命令行参数中设置，而且，expire 和 timeout 是两个不同层次上的概念：</li></ul></li></ul><pre><code>- expire 是指任务的过期时间。这个时间是全局的，影响到所有的work进程。(不管是独立的work命令还是 listen 模式下创建的的work子进程) 。expire 针对的对象是 **任务**。
- timeout 是指work子进程的超时时间。这个时间只对当前执行的listen 命令有效。timeout 针对的对象是 **work子进程**。</code></pre><ul><li><p><strong>2.3.5 使用场景不同</strong><br>根据上面的介绍，可以看到，<br>work 命令的适用场景是：</p><ul><li>任务数量较多</li><li>性能要求较高</li><li>任务的执行时间较短</li><li>消费者类中不存在死循环，sleep() ，exit() ,die() 等容易导致bug的逻辑</li></ul><p>listen命令的适用场景是：</p><ul><li>任务数量较少</li><li>任务的执行时间较长(如生成大型的excel报表等)，</li><li>任务的执行时间需要有严格限制</li></ul></li></ul><h3 id="2-4-消息队列的开始，停止与重启"><a href="#2-4-消息队列的开始，停止与重启" class="headerlink" title="2.4 消息队列的开始，停止与重启"></a>2.4 消息队列的开始，停止与重启</h3><h4 id="开始一个消息队列："><a href="#开始一个消息队列：" class="headerlink" title="开始一个消息队列："></a>开始一个消息队列：</h4><pre class="line-numbers language-bash"><code class="language-bash">php think queue:work<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="停止所有的消息队列："><a href="#停止所有的消息队列：" class="headerlink" title="停止所有的消息队列："></a>停止所有的消息队列：</h4><pre class="line-numbers language-bash"><code class="language-bash">php think queue:restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="重启所有的消息队列："><a href="#重启所有的消息队列：" class="headerlink" title="重启所有的消息队列："></a>重启所有的消息队列：</h4><pre class="line-numbers language-bash"><code class="language-bash">php think queue:restart
php think queue:work<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-5-多模块，多任务的处理"><a href="#2-5-多模块，多任务的处理" class="headerlink" title="2.5 多模块，多任务的处理"></a>2.5 多模块，多任务的处理</h3><h4 id="多模块"><a href="#多模块" class="headerlink" title="多模块"></a>多模块</h4><blockquote><p>单模块项目推荐使用 <code>app\job</code> 作为任务类的命名空间</p></blockquote><blockquote><p>多模块项目可用使用 <code>app\module\job</code> 作为任务类的命名空间 也可以放在任意可以自动加载到的地方</p></blockquote><h4 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h4><blockquote><p>如果一个任务类里有多个小任务的话，在发布任务时，需要用 <code>任务的类名@方法名</code> 如 <code>app\lib\job\Job2@task1</code>、<code>app\lib\job\Job2@task2</code></p></blockquote><blockquote><p>注意：命令行中的 –queue 参数不支持@解析</p></blockquote><p>多任务例子:<br>在 <code>\application\index\controller\JobTest.php</code> 控制器中，添加 <code>actionWithMultiTask()</code>方法：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">actionWithMultiTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

  <span class="token variable">$taskType</span> <span class="token operator">=</span> <span class="token variable">$_GET</span><span class="token punctuation">[</span><span class="token string">'taskType'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token variable">$whichTask</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
       <span class="token keyword">case</span> <span class="token string">'taskA'</span><span class="token punctuation">:</span>
           <span class="token variable">$jobHandlerClassName</span>  <span class="token operator">=</span> <span class="token string">'application\index\job\MultiTask@taskA'</span><span class="token punctuation">;</span>
           <span class="token variable">$jobDataArr</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'1'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
           <span class="token variable">$jobQueueName</span> <span class="token operator">=</span> <span class="token string">"multiTaskJobQueue"</span><span class="token punctuation">;</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
       <span class="token keyword">case</span> <span class="token string">'taskB'</span><span class="token punctuation">:</span>
           <span class="token variable">$jobHandlerClassName</span>  <span class="token operator">=</span> <span class="token string">'application\index\job\MultiTask@taskB'</span><span class="token punctuation">;</span>
           <span class="token variable">$jobDataArr</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'b'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'2'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
           <span class="token variable">$jobQueueName</span> <span class="token operator">=</span> <span class="token string">"multiTaskJobQueue"</span><span class="token punctuation">;</span>        
           <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token punctuation">:</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
   <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

  <span class="token variable">$isPushed</span> <span class="token operator">=</span> Queue<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token variable">$jobHandlerClassName</span><span class="token punctuation">,</span> <span class="token variable">$jobDataArr</span><span class="token punctuation">,</span> <span class="token variable">$jobQueueName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$isPushed</span> <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
    <span class="token keyword">echo</span><span class="token punctuation">(</span><span class="token string">"the $taskType of MultiTask Job has been Pushed to "</span><span class="token punctuation">.</span><span class="token variable">$jobQueueName</span> <span class="token punctuation">.</span><span class="token string">"&lt;br>"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"push a new $taskType of MultiTask Job Failed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
<span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>新增 <code>\application\index\job\MultiTask.php</code> 消费者类，并编写其 <code>taskA()</code> 和 <code>taskB()</code>方法</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token comment" spellcheck="true">/**
 * 文件路径： \application\index\job\MultiTask.php
 * 这是一个消费者类，用于处理 multiTaskJobQueue 队列中的任务
 */</span>
<span class="token keyword">namespace</span> <span class="token package">application<span class="token punctuation">\</span>index<span class="token punctuation">\</span>job</span><span class="token punctuation">;</span>

<span class="token keyword">use</span> <span class="token package">think<span class="token punctuation">\</span>queue<span class="token punctuation">\</span>Job</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MultiTask</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">taskA</span><span class="token punctuation">(</span>Job <span class="token variable">$job</span><span class="token punctuation">,</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

        <span class="token variable">$isJobDone</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_doTaskA</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$isJobDone</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
            <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Info: TaskA of Job MultiTask has been done and deleted"</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">attempts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
                <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">taskB</span><span class="token punctuation">(</span>Job <span class="token variable">$job</span><span class="token punctuation">,</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

        <span class="token variable">$isJobDone</span> <span class="token operator">=</span> <span class="token variable">$this</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">_doTaskA</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$isJobDone</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
            <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Info: TaskB of Job MultiTask has been done and deleted"</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;else&amp;#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">attempts</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
                <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     
            <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">_doTaskA</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Info: doing TaskA of Job MultiTask "</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

    <span class="token keyword">private</span> <span class="token keyword">function</span> <span class="token function">_doTaskB</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Info: doing TaskB of Job MultiTask "</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-6-消息的延迟执行与定时执行"><a href="#2-6-消息的延迟执行与定时执行" class="headerlink" title="2.6 消息的延迟执行与定时执行"></a>2.6 消息的延迟执行与定时执行</h3><p>延迟执行，相对于即时执行，是用来限制某个任务的最早可执行时刻。在到达该时刻之前，该任务会被跳过。</p><p>可以利用该功能实现<strong>定时任务</strong>。</p><p>使用方式：</p><h4 id="在生产者业务代码中："><a href="#在生产者业务代码中：" class="headerlink" title="在生产者业务代码中："></a>在生产者业务代码中：</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 即时执行</span>
<span class="token variable">$isPushed</span> <span class="token operator">=</span> Queue<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token variable">$jobHandlerClassName</span><span class="token punctuation">,</span> <span class="token variable">$jobDataArr</span><span class="token punctuation">,</span> <span class="token variable">$jobQueueName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 延迟 2 秒执行</span>
<span class="token variable">$isPushed</span> <span class="token operator">=</span> Queue<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">later</span><span class="token punctuation">(</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token variable">$jobHandlerClassName</span><span class="token punctuation">,</span> <span class="token variable">$jobDataArr</span><span class="token punctuation">,</span> <span class="token variable">$jobQueueName</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 延迟到 2017-02-18 01:01:01 时刻执行</span>
<span class="token variable">$time2wait</span> <span class="token operator">=</span> <span class="token function">strtotime</span><span class="token punctuation">(</span><span class="token string">'2017-02-18 01:01:01'</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">strtotime</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$isPushed</span> <span class="token operator">=</span> Queue<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">later</span><span class="token punctuation">(</span><span class="token variable">$time2wait</span><span class="token punctuation">,</span><span class="token variable">$jobHandlerClassName</span><span class="token punctuation">,</span> <span class="token variable">$jobDataArr</span><span class="token punctuation">,</span> <span class="token variable">$jobQueueName</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在消费者类中："><a href="#在消费者类中：" class="headerlink" title="在消费者类中："></a>在消费者类中：</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 重发，即时执行</span>
<span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 重发，延迟 2 秒执行</span>
<span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// 延迟到 2017-02-18 01:01:01 时刻执行</span>
<span class="token variable">$time2wait</span> <span class="token operator">=</span> <span class="token function">strtotime</span><span class="token punctuation">(</span><span class="token string">'2017-02-18 01:01:01'</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">strtotime</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token variable">$time2wait</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="在命令行中："><a href="#在命令行中：" class="headerlink" title="在命令行中："></a>在命令行中：</h4><pre class="line-numbers language-bash"><code class="language-bash">//如果消费者类的fire<span class="token punctuation">(</span><span class="token punctuation">)</span>方法抛出了异常且任务未被删除时，将自动重发该任务，重发时，会设置其下次执行前延迟多少秒,默认为0
php think queue:work --delay 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-7-消息的重发"><a href="#2-7-消息的重发" class="headerlink" title="2.7 消息的重发"></a>2.7 消息的重发</h3><p>thinkphp-queue 中，消息的重发时机有3种：</p><h4 id="2-7-1-在消费者类中手动重发："><a href="#2-7-1-在消费者类中手动重发：" class="headerlink" title="2.7.1 在消费者类中手动重发："></a>2.7.1 在消费者类中手动重发：</h4><pre class="line-numbers language-php"><code class="language-php"><span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token variable">$isJobDone</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
    <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-work进程自动重发，需同时满足以下两个条件"><a href="#2-7-2-work进程自动重发，需同时满足以下两个条件" class="headerlink" title="2.7.2 work进程自动重发，需同时满足以下两个条件"></a>2.7.2 work进程自动重发，需同时满足以下两个条件</h4><ul><li>消费者类的 fire() 方法抛出了异常</li><li>任务未被删除</li></ul><h4 id="2-7-3-当配置了-expire-不为-null-时，work-进程内部每次查询可用任务之前，会先自动重发已过期的任务。"><a href="#2-7-3-当配置了-expire-不为-null-时，work-进程内部每次查询可用任务之前，会先自动重发已过期的任务。" class="headerlink" title="2.7.3 当配置了 expire 不为 null 时，work 进程内部每次查询可用任务之前，会先自动重发已过期的任务。"></a>2.7.3 当配置了 expire 不为 <code>null</code> 时，work 进程内部每次查询可用任务之前，会先自动重发已过期的任务。</h4><blockquote><p>补充：</p></blockquote><blockquote><p>在database 模式下，2.7.1 和 2.7.2 中的重发逻辑是先删除原来的任务，然后插入一个新的任务。2.7.3 中的重发时机是直接更新原任务。</p></blockquote><blockquote><p>而在redis 模式下，3种重发都是先删除再插入。</p></blockquote><blockquote><p>不管是哪种重发方式，重发之后，任务的已尝试次数会在原来的基础上 +1 。</p></blockquote><p>此外，消费者类中需要注意，如果 <code>fire()</code> 方法中可能抛出异常，那么</p><ul><li>如果不需要自动重发的话， 请在抛出异常之前将任务删除 <code>$job-&gt;delete()</code> ，以免产生bug。</li><li>如果需要自动重发的话，请直接抛出异常，不要在 <code>fire()</code> 方法中又手动使用 <code>$job-&gt;release()</code> , 这样会导致该任务被重发两次，产生两个一样的新任务。</li></ul><h3 id="2-8-任务的失败回调及告警"><a href="#2-8-任务的失败回调及告警" class="headerlink" title="2.8 任务的失败回调及告警"></a>2.8 任务的失败回调及告警</h3><p>当同时满足以下条件时，将触发任务失败回调：</p><ul><li>命令行的 <code>--tries</code> 参数的值大于0</li><li>任务的已尝试次数大于 命令行的 <code>--tries</code> 参数</li><li>开发者添加了 <code>queue_failed</code> 事件标签及其对应的回调代码</li><li>消费者类中定义了 <code>failed()</code> 方法，用于接收任务失败的通知</li></ul><p>注意， <code>queue_failed</code> 标签需要在安装了 <code>thinkphp-queue</code> 之后 <strong>手动</strong> 去 <code>\application\tags.php</code> 文件中添加。</p><p><strong>注意：该版本有<a target="_blank" rel="noopener" href="https://github.com/top-think/think-queue/issues/10">bug</a>，若想实现失败任务回调功能，需要先修改位于 <code>think-queue\src\queue\Worker.php</code> 中的 <code>logFailedJob</code>方法 , 修改方式如下:</strong></p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">/**
 * Log a failed job into storage.
 * @param  \Think\Queue\Job $job
 * @return array
 */</span>
    <span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function">logFailedJob</span><span class="token punctuation">(</span>Job <span class="token variable">$job</span><span class="token punctuation">)</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
        <span class="token comment" spellcheck="true">// 将原来的 queue.failed' 修改为 'queue_failed' 才可以触发任务失败回调</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Hook<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token string">'queue.failed'</span><span class="token punctuation">,</span> <span class="token variable">$job</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;  </span>
            <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">delete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token variable">$job</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">failed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>

        <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'job'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$job</span><span class="token punctuation">,</span> <span class="token string">'failed'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token boolean">true</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先，我们添加 <code>queue_failed</code> 事件标签, 及其对应的回调方法</p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">// 文件路径： \application\tags.php</span>
<span class="token comment" spellcheck="true">// 应用行为扩展定义文件</span>
<span class="token keyword">return</span> <span class="token punctuation">[</span>
    <span class="token comment" spellcheck="true">// 应用初始化</span>
    <span class="token string">'app_init'</span>     <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 应用开始</span>
    <span class="token string">'app_begin'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 模块初始化</span>
    <span class="token string">'module_init'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 操作开始执行</span>
    <span class="token string">'action_begin'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 视图内容过滤</span>
    <span class="token string">'view_filter'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 日志写入</span>
    <span class="token string">'log_write'</span>    <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token comment" spellcheck="true">// 应用结束</span>
    <span class="token string">'app_end'</span>      <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>

    <span class="token comment" spellcheck="true">// 任务失败统一回调,有四种定义方式</span>
    <span class="token string">'queue_failed'</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>

         <span class="token comment" spellcheck="true">// 数组形式，[ 'ClassName' , 'methodName']</span>
        <span class="token punctuation">[</span><span class="token string">'application\\behavior\\MyQueueFailedLogger'</span><span class="token punctuation">,</span> <span class="token string">'logAllFailedQueues'</span><span class="token punctuation">]</span>

         <span class="token comment" spellcheck="true">// 字符串(静态方法)，'StaicClassName::methodName'</span>
         <span class="token comment" spellcheck="true">// 'MyQueueFailedLogger::logAllFailedQueues'   </span>

         <span class="token comment" spellcheck="true">// 字符串(对象方法)，'ClassName'，此时需在对应的ClassName类中添加一个名为 queueFailed 的方法</span>
         <span class="token comment" spellcheck="true">// 'application\\behavior\\MyQueueFailedLogger'</span>

         <span class="token comment" spellcheck="true">// 闭包形式</span>
         <span class="token comment" spellcheck="true">/*
         function( &amp;$jobObject , $extra)&amp;#123;
             // var_dump($jobObject);
             return true;
         &amp;#125;
         */</span>
    <span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里，我们选择数组形式的回调方式，新增 <code>\application\behavior\MyQueueFailedLogger</code> 类，添加一个 <code>logAllFailedQueues()</code> 方法</p><pre class="line-numbers language-php"><code class="language-php"><span class="token delimiter">&lt;?php</span>
<span class="token comment" spellcheck="true">/**
 * 文件路径: \application\behavior\MyQueueFailedLogger.php
 * 这是一个行为类，用于处理所有的消息队列中的任务失败回调
 */</span>

<span class="token keyword">namespace</span> <span class="token package">application<span class="token punctuation">\</span>behavior</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">MyQueueFailedLogger</span> <span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

    <span class="token keyword">const</span> should_run_hook_callback <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

    <span class="token comment" spellcheck="true">/**
     * @param $jobObject   \think\queue\Job   //任务对象，保存了该任务的执行情况和业务数据
     * @return bool     true                  //是否需要删除任务并触发其failed() 方法
     */</span>
    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">logAllFailedQueues</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$jobObject</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>

        <span class="token variable">$failedJobLog</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
            <span class="token string">'jobHandlerClassName'</span>   <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$jobObject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 'application\index\job\Hello'</span>
            <span class="token string">'queueName'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$jobObject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>               <span class="token comment" spellcheck="true">// 'helloJobQueue'     </span>
            <span class="token string">'jobData'</span>   <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$jobObject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">getRawBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// '&amp;#123;'a': 1 &amp;#125;'</span>
            <span class="token string">'attempts'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$jobObject</span><span class="token operator">-</span><span class="token operator">></span><span class="token function">attempts</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token comment" spellcheck="true">// 3</span>
        <span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token function">var_export</span><span class="token punctuation">(</span><span class="token function">json_encode</span><span class="token punctuation">(</span><span class="token variable">$failedJobLog</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

           <span class="token comment" spellcheck="true">// $jobObject->release();     //重发任务</span>
          <span class="token comment" spellcheck="true">//$jobObject->delete();         //删除任务</span>
          <span class="token comment" spellcheck="true">//$jobObject->failed();      //通知消费者类任务执行失败</span>

        <span class="token keyword">return</span> self<span class="token punctuation">:</span><span class="token punctuation">:</span>should_run_hook_callback<span class="token punctuation">;</span>         
    <span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span>
<span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>需要注意该回调方法的返回值：</p><ul><li>返回 true 时，系统会自动删除该任务，并且自动调用消费者类中的 <code>failed()</code> 方法</li><li>返回 false 时，系统不会自动删除该任务，也不会自动调用消费者类中的 <code>failed()</code> 方法，需要开发者另行处理失败任务的删除和通知。</li></ul><p>最后，在消费者类中，添加 <code>failed()</code> 方法</p><pre class="line-numbers language-php"><code class="language-php"><span class="token comment" spellcheck="true">/**
 * 文件路径： \application\index\job\HelloJob.php
 */</span>

<span class="token comment" spellcheck="true">/**
 * 该方法用于接收任务执行失败的通知，你可以发送邮件给相应的负责人员
 * @param $jobData  string|array|...      //发布任务时传递的 jobData 数据
 */</span>
<span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function">failed</span><span class="token punctuation">(</span><span class="token variable">$jobData</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token shell-comment comment">#123;</span>
    <span class="token function">send_mail_to_somebody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Warning: Job failed after max retries. job data is :"</span><span class="token punctuation">.</span><span class="token function">var_export</span><span class="token punctuation">(</span><span class="token variable">$data</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span><span class="token shell-comment comment">#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样，就可以做到任务失败的<strong>记录</strong>与<strong>告警</strong></p><h3 id="2-9-处理过期的任务"><a href="#2-9-处理过期的任务" class="headerlink" title="2.9 处理过期的任务"></a>2.9 处理过期的任务</h3><p>过期这个概念用文字比较难描述清楚，建议先看一下 <strong>深入理解</strong> 中 <strong>3.4 消息处理的详细流程图</strong></p><h2 id="三-深入理解"><a href="#三-深入理解" class="headerlink" title="三 深入理解"></a>三 深入理解</h2><h3 id="3-1-thinkphp-queue-中消息与队列的保存方式"><a href="#3-1-thinkphp-queue-中消息与队列的保存方式" class="headerlink" title="3.1 thinkphp-queue 中消息与队列的保存方式"></a>3.1 thinkphp-queue 中消息与队列的保存方式</h3><ul><li><p>Redis</p><p>在 Redis 中，每一个 队列 都三个key 与之对应 ，以 helloJobQueue 队列举例，其在redis 中的保存方式为：</p><table><thead><tr><th>key名</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>queues:helloJobQueue</td><td>List ， 列表</td><td>待执行的任务列表</td></tr><tr><td>queues:helloJobQueue:delayed</td><td>Sorted Set，有序集合</td><td>延迟执行和定时执行的任务集合</td></tr><tr><td>queues:helloJobQueue:reserved</td><td>Sorted Set，有序集合</td><td>执行中的任务集合</td></tr></tbody></table><blockquote><p>使用的<code>:</code>分隔符, 只是用来表示相关key的关联性。本身没有特殊含义。使用分隔符是一种常见的组织key的方式。</p></blockquote><p>其中，在<code>queues:helloJobQueue</code> 列表中，每个元素的形式如下：</p><p><img src="/posts/75f8d643/redis%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97-queue.png" alt="redis中的队列-queue"></p><p>在 <code>queues:helloJobQueue:delayed</code> 和 <code>queues:helloJobQueue:delayed</code> 有序集合中，每个元素的形式如下：</p><p><img src="/posts/75f8d643/redis%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97-queue-reserved.png" alt="redis中的队列-queue-reserved"></p><p>可以看到，在有序集合中，每个元素代表一个任务，该元素的 Score 为该任务的入队时间戳，任务的 value 为json 格式，保存了任务的执行情况和业务数据。将value decode 为数组后形式如下：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token punctuation">[</span>
  <span class="token string">'job'</span>  <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'application\\index\\job\\Hello'</span> <span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// jobHandlerClassName，消费者类的类名</span>
  <span class="token string">'data'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span>                      <span class="token comment" spellcheck="true">// 生产者传入的业务数据</span>
     <span class="token string">'time'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'2017-02-18 16:20:10'</span><span class="token punctuation">,</span>
     <span class="token string">'data'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'I have 648 apples'</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token string">'id'</span>   <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'77IasdasadIasdadadadKL8t'</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">// 一个随机的32位字符串</span>
  <span class="token string">'attempts'</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token number">2</span>                <span class="token comment" spellcheck="true">// 任务的已尝试次数</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移，详情可见 3.5</p></li><li><p>Database</p><p>在 Database 中，每个任务对应到表中的一行，queue 字段用来区分不同的队列。</p><p>表的字段结构如下:</p><p><img src="/posts/75f8d643/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E.png" alt="数据库字段说明"></p><p>其中，payLoad 字段保存了消息的执行者和业务数据，payLoad 字段采用 json 格式的字符串来保存消息，将其 decode 为数组后形式如下：</p><pre class="line-numbers language-php"><code class="language-php"><span class="token punctuation">[</span>
 <span class="token string">'job'</span>   <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'application\\index\\job\\Hello'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// jobHandlerClassName，消费者类的类名</span>
 <span class="token string">'data'</span>  <span class="token operator">=</span><span class="token operator">></span> string<span class="token operator">|</span><span class="token keyword">array</span><span class="token operator">|</span>integer<span class="token operator">|</span>object       <span class="token comment" spellcheck="true">// 生产者传入的业务数据</span>
<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3-2-thinkphp-queue-的目录结构和类关系图"><a href="#3-2-thinkphp-queue-的目录结构和类关系图" class="headerlink" title="3.2 thinkphp-queue 的目录结构和类关系图"></a>3.2 thinkphp-queue 的目录结构和类关系图</h3><p><img src="/posts/75f8d643/thinkphp-queue%E7%9A%84%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="thinkphp-queue的文件目录"></p><p>这些类构成了消息队列中的几个角色：</p><table><thead><tr><th>角色</th><th>类名</th><th>说明</th></tr></thead><tbody><tr><td>命令行</td><td>Command + Worker</td><td>负责解析命令行参数，控制队列的启动，重启</td></tr><tr><td>驱动</td><td>Queue + Connector</td><td>负责队列的创建，以及消息的入队，出队等操作</td></tr><tr><td>任务</td><td>Job</td><td>用于将消息转化为一个任务对象，供消费者使用</td></tr><tr><td>生产者</td><td>业务代码</td><td>负责消息的创建与发布</td></tr><tr><td>消费者</td><td>业务代码</td><td>负责任务的接收与执行</td></tr></tbody></table><p>各个类之间的关系图如下：</p><p><img src="https://blog.huzhongyuan.com/wp-content/uploads/2017/02/thinkphp-queue%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.svg" alt="thinkphp-queue类关系图"></p><h3 id="3-3-Deamon模式的执行流程"><a href="#3-3-Deamon模式的执行流程" class="headerlink" title="3.3 Deamon模式的执行流程"></a>3.3 Deamon模式的执行流程</h3><p><img src="https://blog.huzhongyuan.com/wp-content/uploads/2017/02/Daemon%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9Edaemon%E6%A8%A1%E5%BC%8F%E7%8A%B6%E6%80%81%E5%9B%BE.svg" alt="Daemon模式与非daemon模式状态图"></p><h3 id="3-4-Database模式下消息处理的详细流程"><a href="#3-4-Database模式下消息处理的详细流程" class="headerlink" title="3.4 Database模式下消息处理的详细流程"></a>3.4 Database模式下消息处理的详细流程</h3><p>下图中，展示了database 模式下消息处理的详细流程，redis 驱动下大体类似</p><p><img src="https://blog.huzhongyuan.com/wp-content/uploads/2017/02/Database%E9%A9%B1%E5%8A%A8%E4%B8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B.svg" alt="Database模式下消息获取和执行的具体流程"></p><h3 id="3-5-redis-驱动下的任务重发细节"><a href="#3-5-redis-驱动下的任务重发细节" class="headerlink" title="3.5 redis 驱动下的任务重发细节"></a>3.5 redis 驱动下的任务重发细节</h3><p>在redis驱动下，为了实现任务的延迟执行和过期重发，任务将在这三个key中来回转移。</p><p>在3.4 Database模式下消息处理的消息流程中，我们知道，如果配置的expire 不是null ，那么 thinkphp-queue的work进程每次在获取下一个可执行任务之前，会先尝试重发所有过期的任务。而在redis驱动下，这个步骤则做了更多的事情，详情如下：</p><ol><li>从 <code>queue:xxx:delayed</code> 的key中查询出有哪些任务在当前时刻已经可以开始执行，然后将这些任务转移到 <code>queue:xxx</code> 的key的尾部。</li><li>从 <code>queue:xxx:reserved</code> 的key中查询出有哪些任务在当前时刻已经过期，然后将这些任务转移到 <code>queue:xxx</code>的key的尾部。</li><li>尝试从 <code>queue:xxx</code> 的key的头部取出一个任务，如果取出成功，那么，将这个任务转移到 <code>queue:xxx:reserved</code> 的key 的头部，同时将这个任务实例化成任务对象，交给消费者去执行。</li></ol><p>用图来表示这个步骤的具体过程如下：</p><p>redis队列中的过期任务重发步骤–执行前：</p><p><img src="https://blog.huzhongyuan.com/wp-content/uploads/2017/02/redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-1.png" alt="redis队列中的过期任务重发步骤-执行前"></p><p>redis队列中的过期任务重发步骤–执行后：</p><p><img src="https://blog.huzhongyuan.com/wp-content/uploads/2017/02/redis%E9%98%9F%E5%88%97%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86-2.png" alt="redis队列中的过期任务重发步骤--执行后"></p><h3 id="3-6-thinkphp-queue的性能"><a href="#3-6-thinkphp-queue的性能" class="headerlink" title="3.6 thinkphp-queue的性能"></a>3.6 thinkphp-queue的性能</h3><ul><li><p>测试环境 :</p><p>虚拟机 Ubuntu 16.04 ， PHP 7.1 ，TP5，Redis 3.2 ， 双核 I5 6400，3G 内存</p></li><li><p>测试方式 :</p><p>使用 Redis 驱动，在一个控制器中循环推送 40000 条消息到消息队列；</p><p>使用<code>php think queue:work --daemon</code>去消费这些消息，计算推送和消费各自所耗的时间。</p></li><li><p>测试结果 :</p><p>在最简单的逻辑下，平均每秒中可推送8000个消息，平均每秒可消费200个消息。</p></li></ul><p><strong>注意：</strong>由于在测试时，Host 机本身的cpu和内存长期100%，并且虚拟机中的各项服务并未专门调优，因此该测试结果<strong>并不具备参考性</strong>。</p><h3 id="3-7-thinkphp-queue-的N种错误使用姿势"><a href="#3-7-thinkphp-queue-的N种错误使用姿势" class="headerlink" title="3.7 thinkphp-queue 的N种错误使用姿势"></a>3.7 thinkphp-queue 的N种错误使用姿势</h3><h4 id="3-7-1-在-消费者类的-fire-方法中，忘记使用-job-gt-delete-去删除消息，这种情况下，会产生一系列的bug："><a href="#3-7-1-在-消费者类的-fire-方法中，忘记使用-job-gt-delete-去删除消息，这种情况下，会产生一系列的bug：" class="headerlink" title="3.7.1 在 消费者类的 fire() 方法中，忘记使用 $job-&gt;delete() 去删除消息，这种情况下，会产生一系列的bug："></a>3.7.1 在 消费者类的 <code>fire()</code> 方法中，忘记使用 <code>$job-&gt;delete()</code> 去删除消息，这种情况下，会产生一系列的bug：</h4><ul><li><p>配置的 expire 为 <code>null</code> ， 则该任务被执行一次后会永远留在消息队列中，占用消息队列的空间 , 除非开发者另行处理。</p></li><li><p>配置的 expire <code>不为 null</code> ，该任务在 expire 秒后被认为是过期任务，并被消息队列还原为待执行状态，在消息队列的后面的循环中继续被获取，这时，如果</p></li><li><p>命令行中的 <code>--tries</code> 参数为0 或者未设置,那么每隔 一段时间该任务就会被执行一次。</p></li><li><p>命令行中的 <code>--tries</code> 参数 n 大于0 ， 那么当这个任务被误执行的次数超过n 时，会由消息队列尝试去触发失败回调事件:</p></li><li><p>如果开发者没有编写失败处理的回调事件：那么该任务仍然不会被删除，每隔一段时间就会被执行一次。[这个可能属于框架的<a target="_blank" rel="noopener" href="https://github.com/top-think/think-queue/issues/10">Bug</a>] ,</p></li><li><p>如果编写了失败回调事件</p><ul><li>回调事件中删除了任务，则这个任务被误执行了 n 次。</li><li>回调事件中未删除任务，这时，如果：<ul><li>回调事件返回值是 false，那么该任务仍然不会被删除，每隔一段时间就会被执行一次</li><li>回调事件返回值是 true， 那么该任务会先被删除，然后触发消费者类的 failed() 方法，如果在 failed() 方法中设置了告警，那么这个告警就是一次误报。</li></ul></li></ul></li></ul><p>因此，在 使用 thinkphp-queue 时，请记得：</p><ul><li><strong>任务完成后, 使用 <code>$job-&gt;delete()</code> 删除任务</strong></li><li>在消费者类的 <code>fire()</code> 方法中，使用 <code>$job-&gt;attempt()</code> 检查任务已执行次数，对于次数异常的，作相应的处理。</li><li>在消费者类的 <code>fire()</code> 方法中，根据业务数据来判断该任务是否已经执行过，以避免该任务被重复执行。</li><li>编写失败回调事件，将事件中失败的任务及时通知给开发人员。</li></ul><h4 id="3-7-2-使用了-queue-work-daemon-，但更新代码后没有使用-queue-restart-重启-work-进程-使得-work-进程中的代码与最新的代码不同，出现各种问题。"><a href="#3-7-2-使用了-queue-work-daemon-，但更新代码后没有使用-queue-restart-重启-work-进程-使得-work-进程中的代码与最新的代码不同，出现各种问题。" class="headerlink" title="3.7.2 使用了 queue:work --daemon ，但更新代码后没有使用 queue:restart 重启 work 进程, 使得 work 进程中的代码与最新的代码不同，出现各种问题。"></a>3.7.2 使用了 <code>queue:work --daemon</code> ，但更新代码后没有使用 <code>queue:restart</code> 重启 work 进程, 使得 work 进程中的代码与最新的代码不同，出现各种问题。</h4><h4 id="3-7-3-使用了-queue-work-daemon-，但是消费者类的-fire-方法中存在死循环，或-sleep-n-等逻辑，导致消息队列被堵塞；或者使用了-exit-die-这样的逻辑，导致work进程直接终止-。"><a href="#3-7-3-使用了-queue-work-daemon-，但是消费者类的-fire-方法中存在死循环，或-sleep-n-等逻辑，导致消息队列被堵塞；或者使用了-exit-die-这样的逻辑，导致work进程直接终止-。" class="headerlink" title="3.7.3 使用了 queue:work --daemon ，但是消费者类的 fire() 方法中存在死循环，或 sleep(n) 等逻辑，导致消息队列被堵塞；或者使用了 exit() , die() 这样的逻辑，导致work进程直接终止 。"></a>3.7.3 使用了 <code>queue:work --daemon</code> ，但是消费者类的 fire() 方法中存在死循环，或 <code>sleep(n)</code> 等逻辑，导致消息队列被堵塞；或者使用了 <code>exit()</code> , <code>die()</code> 这样的逻辑，导致work进程直接终止 。</h4><h4 id="3-7-4-配置的-expire-为-null-，这时如果采用的是-Redis-驱动且使用了延迟功能，如-later-n-，-release-n-方法或者-delay-参数不为0-，-那么将导致被延迟的任务永远无法处理。-这个可能属于框架的Bug"><a href="#3-7-4-配置的-expire-为-null-，这时如果采用的是-Redis-驱动且使用了延迟功能，如-later-n-，-release-n-方法或者-delay-参数不为0-，-那么将导致被延迟的任务永远无法处理。-这个可能属于框架的Bug" class="headerlink" title="3.7.4 配置的 expire 为 null ，这时如果采用的是 Redis 驱动且使用了延迟功能，如 later(n) ， release(n) 方法或者 --delay 参数不为0 ， 那么将导致被延迟的任务永远无法处理。(这个可能属于框架的Bug)"></a>3.7.4 配置的 expire 为 <code>null</code> ，这时如果采用的是 Redis 驱动且使用了延迟功能，如 <code>later(n)</code> ， <code>release(n)</code> 方法或者 <code>--delay</code> 参数不为0 ， 那么将导致被延迟的任务永远无法处理。(这个可能属于框架的<a target="_blank" rel="noopener" href="https://github.com/top-think/think-queue/issues/12">Bug</a>)</h4><h4 id="3-7-5-配置的-expire-为null-，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。"><a href="#3-7-5-配置的-expire-为null-，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。" class="headerlink" title="3.7.5 配置的 expire 为null ，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。"></a>3.7.5 配置的 expire 为<code>null</code> ，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。</h4><h4 id="3-7-6-配置的-expire-不为null-，但配置的-expire-时间太短，以至于-expire-时间-lt-消费者的-fire-方法所需时间-删除该任务所需的时间-，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。"><a href="#3-7-6-配置的-expire-不为null-，但配置的-expire-时间太短，以至于-expire-时间-lt-消费者的-fire-方法所需时间-删除该任务所需的时间-，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。" class="headerlink" title="3.7.6 配置的 expire 不为null ，但配置的 expire 时间太短，以至于 expire 时间 &lt; 消费者的 fire() 方法所需时间 + 删除该任务所需的时间 ，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。"></a>3.7.6 配置的 expire <code>不为null</code> ，但配置的 expire 时间太短，以至于 expire 时间 &lt; 消费者的 <code>fire()</code> 方法所需时间 + 删除该任务所需的时间 ，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。</h4><h4 id="3-7-7-使用-Queue-push-jobHandlerClassName-jobData-jobQueueName-推送任务时，-jobData-中包含未序列化的对象。这时，在消费者端拿到的-jobData-中拿到的是该对象的public-属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。"><a href="#3-7-7-使用-Queue-push-jobHandlerClassName-jobData-jobQueueName-推送任务时，-jobData-中包含未序列化的对象。这时，在消费者端拿到的-jobData-中拿到的是该对象的public-属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。" class="headerlink" title="3.7.7 使用 Queue::push($jobHandlerClassName , $jobData, $jobQueueName ); 推送任务时，$jobData 中包含未序列化的对象。这时，在消费者端拿到的 $jobData 中拿到的是该对象的public 属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。"></a>3.7.7 使用 <code>Queue::push($jobHandlerClassName , $jobData, $jobQueueName );</code> 推送任务时，<code>$jobData</code> 中包含未序列化的对象。这时，在消费者端拿到的 <code>$jobData</code> 中拿到的是该对象的public 属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。</h4><h2 id="四-拓展"><a href="#四-拓展" class="headerlink" title="四 拓展"></a>四 拓展</h2><h3 id="4-1-队列的稳定性和拓展性"><a href="#4-1-队列的稳定性和拓展性" class="headerlink" title="4.1 队列的稳定性和拓展性"></a>4.1 队列的稳定性和拓展性</h3><ul><li><p>稳定性：不管是 listen 模式还是 work 模式，都建议使用 supervisor 或者 自定义的cron 脚本，去定时检查 work 进程是否正常</p></li><li><p>拓展性： 当某个队列的消费者不足时，再给这个队列添加 work进程即可。</p><h3 id="4-2-消息队列的可视化管理工具"><a href="#4-2-消息队列的可视化管理工具" class="headerlink" title="4.2 消息队列的可视化管理工具"></a>4.2 消息队列的可视化管理工具</h3></li><li><p>队列管理，队列的列表，队列的 work 进程数量控制，队列的任务数量变化趋势 //TBD</p></li><li><p>任务管理，任务的列表，添加/<strong>撤回</strong>/查询任务，修改任务的 执行者/执行时间/优先级/数据 等 //TBD</p><h3 id="4-2-编写自定义的-thinkphp-queue-驱动"><a href="#4-2-编写自定义的-thinkphp-queue-驱动" class="headerlink" title="4.2 编写自定义的 thinkphp-queue 驱动"></a>4.2 编写自定义的 thinkphp-queue 驱动</h3><p>//TBD</p><h3 id="4-3-编写消息队列的单元测试"><a href="#4-3-编写消息队列的单元测试" class="headerlink" title="4.3 编写消息队列的单元测试"></a>4.3 编写消息队列的单元测试</h3><p>//TBD</p><h3 id="4-4-与其他PHP消息队列库的对比"><a href="#4-4-与其他PHP消息队列库的对比" class="headerlink" title="4.4 与其他PHP消息队列库的对比"></a>4.4 与其他PHP消息队列库的对比</h3><p>TP5的消息队列与Laravel的消息队列比较相似，下面是与laravel 中的消息队列的一些对比：</p><table><thead><tr><th></th><th>thinkphp-queue (v1.1.2)</th><th>laravel-queue (v5.3)</th></tr></thead><tbody><tr><td>内置的驱动</td><td>Database，Redis，Sync，TopThink</td><td>Database，Redis, Sync(在laravel中称为 null)。</td></tr><tr><td>Redis驱动要求</td><td>装redis的C扩展</td><td>安装 predis 包 + LUA脚本 推送任务</td></tr><tr><td>推送任务</td><td>允许推送 消费者类名，消费者对象</td><td>允许推送消费者类名，消费者对象，闭包</td></tr><tr><td>失败任务处理</td><td>触发失败回调事件 (有Bug)</td><td>触发失败回调事件 + 移动任务到 failed_jobs表?</td></tr><tr><td>消息订阅</td><td>subscribe 命令+ Topthink驱动(注：未实现/未提供)</td><td>subscribe 命令 + 安装IronMQ 驱动</td></tr><tr><td>删除任务</td><td>消费者类中手动删除</td><td>任务完成后自动删除</td></tr><tr><td>推送到多个队列</td><td>需自己实现</td><td>原生支持</td></tr><tr><td>延迟执行</td><td>支持 (有Bug)</td><td>支持</td></tr><tr><td>消息重发</td><td>支持</td><td>支持</td></tr><tr><td>检查已执行次数</td><td>原生支持</td><td>需在消费者类中显式 use 相关的 trait</td></tr><tr><td>执行方式</td><td>work 模式 + listen 模式</td><td>work 模式 + listen 模式</td></tr><tr><td>进程命令</td><td>开启，停止，重启</td><td>开启，停止，重启</td></tr><tr><td>任务命令</td><td>无</td><td>展示失败任务列表，重试某个失败任务，删除某个失败任务</td></tr><tr><td>支持的事件</td><td>失败回调事件</td><td>失败回调事件，支持消费前事件，消费后事件</td></tr></tbody></table></li></ul><p>使用supervisor管理think-queue示例</p><p>配置文件 /etc/supervisord.conf 末尾添加以下代码：</p><pre class="line-numbers language-sh"><code class="language-sh">[program:php]
command= /usr/bin/php think queue:work --queue notify --daemon ; 被监控进程
directory=/home/wwwroot/dlsj.mrpzx.com
;process_name=%(process_num)02d
;numprocs=5 #启动几个进程
autostart=true ;随着supervisord的启动而启动
autorestart=true ;自动启动
startsecs=1 ;程序重启时候停留在runing状态的秒数
startretries=10 ;启动失败时的最多重试次数
redirect_stderr=true ;重定向stderr到stdout
stdout_logfile=/root/supervisor.log ;stdout文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复制代码 值得注意的是 每行的 ; 要跟前面的命令用空格隔开， 不能挨着， 然后注释文字要以;开头， 不能#开头 ，每行 ; 作为命令的结尾</p></div><div id="side-right-bar"><div class="close-right-bar"></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经阅读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85supervisor"><span class="toc-number">1.</span> <span class="toc-text">安装supervisor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96supervisor%E5%8C%85%EF%BC%9A%E3%80%90https-pypi-python-org-pypi-supervisor%E3%80%91"><span class="toc-number">1.1.</span> <span class="toc-text">1.获取supervisor包：【https:&#x2F;&#x2F;pypi.python.org&#x2F;pypi&#x2F;supervisor】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%A3%E5%8E%8Bsupervisor-3-3-1-tar-gz-%E5%B9%B6%E5%AE%89%E8%A3%85"><span class="toc-number">1.2.</span> <span class="toc-text">2.解压supervisor-3.3.1.tar.gz 并安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BAsupervisor%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">1.3.</span> <span class="toc-text">3.创建supervisor的配置文件：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%BC%80%E5%90%AFsupervisord%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">4.开启supervisord服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9B%B4%E6%96%B0%E6%96%B0%E7%9A%84%E9%85%8D%E7%BD%AE%E5%88%B0supervisord"><span class="toc-number">1.5.</span> <span class="toc-text">5.更新新的配置到supervisord</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.</span> <span class="toc-text">6.重新启动配置中的所有程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%90%AF%E5%8A%A8%E6%9F%90%E4%B8%AA%E8%BF%9B%E7%A8%8B-program-name-%E4%BD%A0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">1.7.</span> <span class="toc-text">7.启动某个进程(program_name&#x3D;你配置中写的程序名称)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E6%9F%A5%E7%9C%8B%E6%AD%A3%E5%9C%A8%E5%AE%88%E5%80%99%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.8.</span> <span class="toc-text">8.查看正在守候的进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%87%8D%E5%90%AF%E6%9F%90%E4%B8%80%E8%BF%9B%E7%A8%8B-program-name-%E4%BD%A0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%86%99%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0"><span class="toc-number">1.9.</span> <span class="toc-text">9.重启某一进程 (program_name&#x3D;你配置中写的程序名称)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%81%9C%E6%AD%A2%E5%85%A8%E9%83%A8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.10.</span> <span class="toc-text">10.停止全部进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%9F%A5%E7%9C%8Bsupervisord%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.11.</span> <span class="toc-text">11.查看supervisord进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.11.1.</span> <span class="toc-text">一 代码示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-thinkphp-queue"><span class="toc-number">2.</span> <span class="toc-text">安装 thinkphp-queue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AD%98%E5%82%A8%E7%8E%AF%E5%A2%83"><span class="toc-number">2.1.</span> <span class="toc-text">搭建消息队列的存储环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.2.</span> <span class="toc-text">配置消息队列的驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%8E%A8%E9%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">消息的创建与推送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%9A%84%E6%B6%88%E8%B4%B9%E4%B8%8E%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.2.</span> <span class="toc-text">消息的消费与删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.2.3.</span> <span class="toc-text">发布任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.2.4.</span> <span class="toc-text">处理任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.3.</span> <span class="toc-text">二 详细介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.1 命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.2 命令行参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-work-%E6%A8%A1%E5%BC%8F%E5%92%8C-listen-%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3 work 模式和 listen 模式的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%BC%80%E5%A7%8B%EF%BC%8C%E5%81%9C%E6%AD%A2%E4%B8%8E%E9%87%8D%E5%90%AF"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.4 消息队列的开始，停止与重启</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">开始一个消息队列：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E6%89%80%E6%9C%89%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">停止所有的消息队列：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E6%89%80%E6%9C%89%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">重启所有的消息队列：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E5%A4%9A%E6%A8%A1%E5%9D%97%EF%BC%8C%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.5 多模块，多任务的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">多模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">多任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E6%B6%88%E6%81%AF%E7%9A%84%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C%E4%B8%8E%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C"><span class="toc-number">2.3.6.</span> <span class="toc-text">2.6 消息的延迟执行与定时执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%9A"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">在生产者业务代码中：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%E4%B8%AD%EF%BC%9A"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">在消费者类中：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%EF%BC%9A"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">在命令行中：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%8F%91"><span class="toc-number">2.3.7.</span> <span class="toc-text">2.7 消息的重发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%E4%B8%AD%E6%89%8B%E5%8A%A8%E9%87%8D%E5%8F%91%EF%BC%9A"><span class="toc-number">2.3.7.1.</span> <span class="toc-text">2.7.1 在消费者类中手动重发：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-2-work%E8%BF%9B%E7%A8%8B%E8%87%AA%E5%8A%A8%E9%87%8D%E5%8F%91%EF%BC%8C%E9%9C%80%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3%E4%BB%A5%E4%B8%8B%E4%B8%A4%E4%B8%AA%E6%9D%A1%E4%BB%B6"><span class="toc-number">2.3.7.2.</span> <span class="toc-text">2.7.2 work进程自动重发，需同时满足以下两个条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-%E5%BD%93%E9%85%8D%E7%BD%AE%E4%BA%86-expire-%E4%B8%8D%E4%B8%BA-null-%E6%97%B6%EF%BC%8Cwork-%E8%BF%9B%E7%A8%8B%E5%86%85%E9%83%A8%E6%AF%8F%E6%AC%A1%E6%9F%A5%E8%AF%A2%E5%8F%AF%E7%94%A8%E4%BB%BB%E5%8A%A1%E4%B9%8B%E5%89%8D%EF%BC%8C%E4%BC%9A%E5%85%88%E8%87%AA%E5%8A%A8%E9%87%8D%E5%8F%91%E5%B7%B2%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%E3%80%82"><span class="toc-number">2.3.7.3.</span> <span class="toc-text">2.7.3 当配置了 expire 不为 null 时，work 进程内部每次查询可用任务之前，会先自动重发已过期的任务。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83%E5%8F%8A%E5%91%8A%E8%AD%A6"><span class="toc-number">2.3.8.</span> <span class="toc-text">2.8 任务的失败回调及告警</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-9-%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.3.9.</span> <span class="toc-text">2.9 处理过期的任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-number">2.4.</span> <span class="toc-text">三 深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-thinkphp-queue-%E4%B8%AD%E6%B6%88%E6%81%AF%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E4%BF%9D%E5%AD%98%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.1.</span> <span class="toc-text">3.1 thinkphp-queue 中消息与队列的保存方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-thinkphp-queue-%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">2.4.2.</span> <span class="toc-text">3.2 thinkphp-queue 的目录结构和类关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-Deamon%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.3.</span> <span class="toc-text">3.3 Deamon模式的执行流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-Database%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-number">2.4.4.</span> <span class="toc-text">3.4 Database模式下消息处理的详细流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-redis-%E9%A9%B1%E5%8A%A8%E4%B8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%8F%91%E7%BB%86%E8%8A%82"><span class="toc-number">2.4.5.</span> <span class="toc-text">3.5 redis 驱动下的任务重发细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-thinkphp-queue%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">2.4.6.</span> <span class="toc-text">3.6 thinkphp-queue的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-thinkphp-queue-%E7%9A%84N%E7%A7%8D%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF"><span class="toc-number">2.4.7.</span> <span class="toc-text">3.7 thinkphp-queue 的N种错误使用姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-1-%E5%9C%A8-%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%E7%9A%84-fire-%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%BF%98%E8%AE%B0%E4%BD%BF%E7%94%A8-job-gt-delete-%E5%8E%BB%E5%88%A0%E9%99%A4%E6%B6%88%E6%81%AF%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%B8%80%E7%B3%BB%E5%88%97%E7%9A%84bug%EF%BC%9A"><span class="toc-number">2.4.7.1.</span> <span class="toc-text">3.7.1 在 消费者类的 fire() 方法中，忘记使用 $job-&gt;delete() 去删除消息，这种情况下，会产生一系列的bug：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-2-%E4%BD%BF%E7%94%A8%E4%BA%86-queue-work-daemon-%EF%BC%8C%E4%BD%86%E6%9B%B4%E6%96%B0%E4%BB%A3%E7%A0%81%E5%90%8E%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8-queue-restart-%E9%87%8D%E5%90%AF-work-%E8%BF%9B%E7%A8%8B-%E4%BD%BF%E5%BE%97-work-%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%9C%80%E6%96%B0%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%90%84%E7%A7%8D%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">2.4.7.2.</span> <span class="toc-text">3.7.2 使用了 queue:work --daemon ，但更新代码后没有使用 queue:restart 重启 work 进程, 使得 work 进程中的代码与最新的代码不同，出现各种问题。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-3-%E4%BD%BF%E7%94%A8%E4%BA%86-queue-work-daemon-%EF%BC%8C%E4%BD%86%E6%98%AF%E6%B6%88%E8%B4%B9%E8%80%85%E7%B1%BB%E7%9A%84-fire-%E6%96%B9%E6%B3%95%E4%B8%AD%E5%AD%98%E5%9C%A8%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%8C%E6%88%96-sleep-n-%E7%AD%89%E9%80%BB%E8%BE%91%EF%BC%8C%E5%AF%BC%E8%87%B4%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%A2%AB%E5%A0%B5%E5%A1%9E%EF%BC%9B%E6%88%96%E8%80%85%E4%BD%BF%E7%94%A8%E4%BA%86-exit-die-%E8%BF%99%E6%A0%B7%E7%9A%84%E9%80%BB%E8%BE%91%EF%BC%8C%E5%AF%BC%E8%87%B4work%E8%BF%9B%E7%A8%8B%E7%9B%B4%E6%8E%A5%E7%BB%88%E6%AD%A2-%E3%80%82"><span class="toc-number">2.4.7.3.</span> <span class="toc-text">3.7.3 使用了 queue:work --daemon ，但是消费者类的 fire() 方法中存在死循环，或 sleep(n) 等逻辑，导致消息队列被堵塞；或者使用了 exit() , die() 这样的逻辑，导致work进程直接终止 。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-4-%E9%85%8D%E7%BD%AE%E7%9A%84-expire-%E4%B8%BA-null-%EF%BC%8C%E8%BF%99%E6%97%B6%E5%A6%82%E6%9E%9C%E9%87%87%E7%94%A8%E7%9A%84%E6%98%AF-Redis-%E9%A9%B1%E5%8A%A8%E4%B8%94%E4%BD%BF%E7%94%A8%E4%BA%86%E5%BB%B6%E8%BF%9F%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%A6%82-later-n-%EF%BC%8C-release-n-%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85-delay-%E5%8F%82%E6%95%B0%E4%B8%8D%E4%B8%BA0-%EF%BC%8C-%E9%82%A3%E4%B9%88%E5%B0%86%E5%AF%BC%E8%87%B4%E8%A2%AB%E5%BB%B6%E8%BF%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%B0%B8%E8%BF%9C%E6%97%A0%E6%B3%95%E5%A4%84%E7%90%86%E3%80%82-%E8%BF%99%E4%B8%AA%E5%8F%AF%E8%83%BD%E5%B1%9E%E4%BA%8E%E6%A1%86%E6%9E%B6%E7%9A%84Bug"><span class="toc-number">2.4.7.4.</span> <span class="toc-text">3.7.4 配置的 expire 为 null ，这时如果采用的是 Redis 驱动且使用了延迟功能，如 later(n) ， release(n) 方法或者 --delay 参数不为0 ， 那么将导致被延迟的任务永远无法处理。(这个可能属于框架的Bug)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-5-%E9%85%8D%E7%BD%AE%E7%9A%84-expire-%E4%B8%BAnull-%EF%BC%8C%E4%BD%86%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%87%AA%E8%A1%8C%E5%A4%84%E7%90%86%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%EF%BC%8C%E5%AF%BC%E8%87%B4%E8%BF%87%E6%9C%9F%E7%9A%84%E4%BB%BB%E5%8A%A1%E5%BE%97%E4%B8%8D%E5%88%B0%E5%A4%84%E7%90%86%EF%BC%8C%E4%B8%94%E4%B8%80%E7%9B%B4%E5%8D%A0%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82"><span class="toc-number">2.4.7.5.</span> <span class="toc-text">3.7.5 配置的 expire 为null ，但并没有自行处理过期的任务，导致过期的任务得不到处理，且一直占用消息队列的空间。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-6-%E9%85%8D%E7%BD%AE%E7%9A%84-expire-%E4%B8%8D%E4%B8%BAnull-%EF%BC%8C%E4%BD%86%E9%85%8D%E7%BD%AE%E7%9A%84-expire-%E6%97%B6%E9%97%B4%E5%A4%AA%E7%9F%AD%EF%BC%8C%E4%BB%A5%E8%87%B3%E4%BA%8E-expire-%E6%97%B6%E9%97%B4-lt-%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84-fire-%E6%96%B9%E6%B3%95%E6%89%80%E9%9C%80%E6%97%B6%E9%97%B4-%E5%88%A0%E9%99%A4%E8%AF%A5%E4%BB%BB%E5%8A%A1%E6%89%80%E9%9C%80%E7%9A%84%E6%97%B6%E9%97%B4-%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BB%BB%E5%8A%A1%E5%B0%86%E8%A2%AB%E8%AF%AF%E8%AE%A4%E4%B8%BA%E6%89%A7%E8%A1%8C%E8%B6%85%E6%97%B6%EF%BC%8C%E4%BB%8E%E8%80%8C%E8%A2%AB%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%BE%85%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%82"><span class="toc-number">2.4.7.6.</span> <span class="toc-text">3.7.6 配置的 expire 不为null ，但配置的 expire 时间太短，以至于 expire 时间 &lt; 消费者的 fire() 方法所需时间 + 删除该任务所需的时间 ，那么任务将被误认为执行超时，从而被消息队列还原为待执行状态。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-7-%E4%BD%BF%E7%94%A8-Queue-push-jobHandlerClassName-jobData-jobQueueName-%E6%8E%A8%E9%80%81%E4%BB%BB%E5%8A%A1%E6%97%B6%EF%BC%8C-jobData-%E4%B8%AD%E5%8C%85%E5%90%AB%E6%9C%AA%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%AF%B9%E8%B1%A1%E3%80%82%E8%BF%99%E6%97%B6%EF%BC%8C%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E6%8B%BF%E5%88%B0%E7%9A%84-jobData-%E4%B8%AD%E6%8B%BF%E5%88%B0%E7%9A%84%E6%98%AF%E8%AF%A5%E5%AF%B9%E8%B1%A1%E7%9A%84public-%E5%B1%9E%E6%80%A7%E7%9A%84%E9%94%AE%E5%80%BC%E5%AF%B9%E6%95%B0%E7%BB%84%E3%80%82%E5%9B%A0%E6%AD%A4%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E6%8E%A8%E9%80%81%E5%89%8D%E6%89%8B%E5%8A%A8%E5%BA%8F%E5%88%97%E5%8C%96%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E6%B6%88%E8%B4%B9%E8%80%85%E7%AB%AF%E5%86%8D%E6%89%8B%E5%8A%A8%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%BF%98%E5%8E%9F%E4%B8%BA%E5%AF%B9%E8%B1%A1%E3%80%82"><span class="toc-number">2.4.7.7.</span> <span class="toc-text">3.7.7 使用 Queue::push($jobHandlerClassName , $jobData, $jobQueueName ); 推送任务时，$jobData 中包含未序列化的对象。这时，在消费者端拿到的 $jobData 中拿到的是该对象的public 属性的键值对数组。因此，需要在推送前手动序列化对象，在消费者端再手动反序列化还原为对象。</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E6%8B%93%E5%B1%95"><span class="toc-number">2.5.</span> <span class="toc-text">四 拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%98%9F%E5%88%97%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7%E5%92%8C%E6%8B%93%E5%B1%95%E6%80%A7"><span class="toc-number">2.5.1.</span> <span class="toc-text">4.1 队列的稳定性和拓展性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">2.5.2.</span> <span class="toc-text">4.2 消息队列的可视化管理工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%BC%96%E5%86%99%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84-thinkphp-queue-%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.5.3.</span> <span class="toc-text">4.2 编写自定义的 thinkphp-queue 驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BC%96%E5%86%99%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.4.</span> <span class="toc-text">4.3 编写消息队列的单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E4%B8%8E%E5%85%B6%E4%BB%96PHP%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%93%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.5.5.</span> <span class="toc-text">4.4 与其他PHP消息队列库的对比</span></a></li></ol></li></ol></li></ol></div></div></div><div class="right-btn" id="right-btn"><span>目录</span></div><div class="article-bottom"><div class="addthis_inline_share_toolbox fr"></div></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span><span class="post-copyright-info"><a href="mailto:undefined">CavinHuang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="http://blog.zukmb.cnposts/75f8d643/">http://blog.zukmb.cn/posts/75f8d643/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span><span class="post-copyright-info">转载请注明来自<a href="http://blog.zukmb.cn" target="_blank" style="font-size: 18px;">CavinHuangのBlog</a>！</span></div></div><div class="article-pagenate"><div class="article-prev fl"><span>←</span><a href="/posts/b6e49358/">记录一次win10+deepin双系统安装过程</a></div><div class="article-next fr"><a href="/posts/b75369f8/">记一次linux超级用户和普通用户出现的差错</a><span>→</span></div></div></article></div><footer class="footer"><div id="toTop" style="display: none;">Back to Top</div><div class="footer-content"><p>©2015 - 2018 By cavinHuang</p><div class="framework-info"><span>Driven -</span> <a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme -</span> <a href=""><span>yoyo</span></a></div><div class="site-count"><ul><div class="site-count-item"><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span></div><div class="site-count-item"><span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span></div></ul></div></div></footer><script>(function(){
var bp = document.createElement('script');
var curProtocol = window.location.protocol.split(':')[0];
if (curProtocol === 'https') {
bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
}
else {
bp.src = 'http://push.zhanzhang.baidu.com/push.js';
}
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(bp, s);
})();
</script><script>(function(){
var src = (document.location.protocol == "http:") ? "http://js.passport.qihucdn.com/11.0.1.js?e055b4dda1d8e03e86cb32d91596a2c5":"https://jspassport.ssl.qhimg.com/11.0.1.js?e055b4dda1d8e03e86cb32d91596a2c5";
document.write('<script src="' + src + '" id="sozz"><\\/script>');
})();
</script><script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-124916034-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'UA-124916034-1');</script></div></div><canvas class="fireworks"></canvas><script src="/js/velocity.ui.min.js"></script><script src="/js/yoyo.js"></script><script src="/js/scroll.js"></script><script src="/js/anime.min.js"></script><script src="/js/fireworks.js"></script><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>